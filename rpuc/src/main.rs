use log::error;
use pixels::{Error, Pixels, SurfaceTexture};
use winit::dpi::LogicalSize;
use winit::event::{Event, VirtualKeyCode};
use winit::event_loop::{ControlFlow, EventLoop};
use winit::window::WindowBuilder;
use winit_input_helper::WinitInputHelper;

use rpu::RPU;

use std::fs::File;
use std::io::BufWriter;

fn get_time() -> u128 {
    let stop = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("Time went backwards");
        stop.as_millis()
}

fn main() -> Result<(), Error> {

    env_logger::init();

    let width = 600;
    let height = 400;

    let mut path_to_main = std::path::PathBuf::new();
    path_to_main.push("main.rpu");

    let mut rpu = RPU::new(width, height);
    let rc = rpu.compile_from_path(path_to_main);

    if let Some(error) = rc.err() {
        let error_text = format!("Compilation error: {} at line {}.", error.description, error.line);
        println!("{}", error_text.as_str());
        return Ok(());
    }

    println!("RPU file compiled successfully.");

    // Write it to file

    if true {
        let path = "image.png";
        let file = File::create(path).unwrap();
        let ref mut w = BufWriter::new(file);

        let mut encoder = png::Encoder::new(w, width as u32, height as u32);
        encoder.set_color(png::ColorType::Rgba);
        encoder.set_depth(png::BitDepth::Eight);
        // Adding text chunks to the header
        encoder
            .add_text_chunk(
                "ForgedThoughts".to_string(),
                "This image was procedurally generated by RPU.".to_string(),
            )
            .unwrap();

        let mut writer = encoder.write_header().unwrap();

        let mut buffer = vec![0;width * height * 4];
        let start = get_time();
        rpu.render(&mut buffer, (0, 0, width, height));
        println!("Image rendered in {} ms", get_time() - start);
        writer.write_image_data(&buffer).unwrap(); // Save

        return Ok(());
    }


    let event_loop = EventLoop::new();
    let mut input = WinitInputHelper::new();
    let window = {
        let size = LogicalSize::new(width as f64, height as f64);

    WindowBuilder::new()
        .with_title("RPU")
        .with_inner_size(size)
        .with_min_inner_size(size)

        .build(&event_loop)
        .unwrap()
    };

    let mut pixels = {
        let window_size = window.inner_size();
        let surface_texture = SurfaceTexture::new(window_size.width, window_size.height, &window);
        Pixels::new(width as u32, height as u32, surface_texture)?
    };

   event_loop.run(move |event, _, control_flow| {
        // Draw the current frame
        if let Event::RedrawRequested(_) = event {
            // let start = get_time();
            rpu.render(&mut pixels.get_frame()[..], (0, 0, width, height));
            // println!("Time: {}", get_time() - start);
            if pixels
                .render()
                .map_err(|e| error!("pixels.render() failed: {}", e))
                .is_err()
            {
                *control_flow = ControlFlow::Exit;
                return;
            }
        }

        // Handle input events
        if input.update(&event) {
            // Close events
            if input.key_pressed(VirtualKeyCode::Escape) || input.quit() {
                *control_flow = ControlFlow::Exit;
                return;
            }

            // Resize the window
            if let Some(size) = input.window_resized() {
                pixels.resize_surface(size.width, size.height);
            }

            // Update internal state and request a redraw
            window.request_redraw();
        }
    });

}